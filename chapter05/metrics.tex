\subsection{Metrics}

To determine the performance of the feature-based approach, the matching of keypoints is framed in terms of a binary classifier.
For a keypoint correspondence between two images the classification task is to determine if those keypoint correspond to the same point in the real world or not.
The correspondence is computed based on the relative pose of consecutive images and only 2 consecutive images are analyzed.
This evaluation is done for \Glspl{bearing-angle-image} and \Glspl{flexion-image}.
The following subsections describe each component of this evaluation pipeline in more detail.
To the best of the author's knowledge no other work approaches the evaluation of feature detectors and descriptors like this.

\subsubsection{Groundtruth Poses}

The dataset \emph{Lehrpfad} provides groundthruth poses from a prior \gls{sfm} reconstruction.
Due to the global optimization of the \gls{sfm} algorithm these poses do not match with the depth values of the depth images.
The other dataset do not contain a precomputed pose.
Each pose is computed and refined with an ICP algorithm, namely OpenCV's \emph{FASTICPOdometry} that is based on the KinectFusion\cite{newcombe_ismar2011} work.
This relative pose serves as foundation of the evaluation and is assumed to be correct within small tolerance.
The accuracy assumption of the \emph{FASTICPOdometry} poses is tested by manual inspection of the backprojection of obviously related keypoints and the results showed no systematic errornous poses.

\subsubsection{Backprojection and Distance Threshold}

In two consecutive images all keypoints are extracted with the choosen algorithm and settings.
The keypoints of the first image is projected into the view of the second images using the determined relative pose and camera model.
This gives two sets of keypoints in the second image, the keypoints detected in this frame and the keypoints detected in the previous frame, seen from this frames pose.
Assuming a correct relative pose, the corresponding keypoints have a small pixel distance between each other.
\emph{Small} is a relative value and the choosen threshold in the experiments is $2px$.
This approach can only result in a proper analysis for a sparse distribution of keypoints that actually respond to image structure and small changes in pose.
When the pose difference is big it can happen that keypoints to covered geometry get projected to the same position as some other valid keypoint.
Too many points create ambiguity with respect to the backprojection tolerance that is required due to imperfect projections of real world sensors.
\begin{figure}[H]
    \input{chapter05/img/backprojection}
    \caption{The choosen approach of projection keypoints between frames is demonstrated in this figure. Keypoints of image $I_1$ are blue dots in both images and the oranges ones are only detected in image $I_2$. Actual correspondences result in very close points in $I_2$, indicated as blue dot with orange border, whereas unrelated points show no proximity. This assumption holds for small changes in pose and relativly sparse distribution of detected keypoints.}
\end{figure}
The analysis of the descriptor performance requires the matching step first, that establishes the correspondences of the matcher.
To classify the result of the descriptor matching, each keypoint needs to be analyzed further.
The result are four sets: \emph{true-positive}, \emph{false-positive}, \emph{true-negative} and \emph{false-negative} as introduced in Section~\ref{sec:statistic_classifier}.
The union of these sets are all detected keypoints.

Partitioning the keypoints is done with the following algorithms.
First the matches are analyzed for true and false positives and true correspondences are removed from further analysis. 
Let $proj$ be the keypoints from $I_1$, backprojected to $I_2$ with the relative pose and the appropriate camera model.
$kps$ are the keypoints from $I_2$, $matches$ are pairs of keypoints the matching algorithm considers as correspondences and $threshold$ is the maximum allowed backprojection error for keypoints to still be considered a true correspondence.
\begin{algorithm}[H]
\setstretch{1.35}
\begin{algorithmic}[0]
\Require{$\forall m \in matches \Rightarrow m.first \in proj \land m.second \in kps$}
\Require{$threshold > 0.0$}
\Ensure{$\vert true \vert + \vert false \vert = \vert matches \vert$}
    \Function{ClassifyPositives}{proj, kps, matches, threshold}
    \ForAll{$m \in matches$}
    \If{$\Call{distance}{proj[m.first], kps[m.second]} < threshold$}
        \State$true \gets true \cup m$
        \State$proj \gets proj \setminus m.first$
        \Comment{Prevent double usage}
    \Else%
        \State$false \gets false \cup m$
    \EndIf%
    \State$kps \gets kps \setminus m.second$
    \EndFor%
    \EndFunction%
\end{algorithmic}
\caption{This algorithm distinguishes between a true and a false positive match.}
\end{algorithm}
After this process some keypoints detected in $I_2$ might be left to analyze for a correspondence that was not assigned during matching, the false negatives.
\begin{algorithm}[H]
\setstretch{1.35}
\begin{algorithmic}
\Require{$threshold > 0.0$}
\Require{$kps_{pre-call}$ does not contain matched keypoints}
\Ensure{$\vert false\_negatives \vert + \vert true\_negatives \vert = \vert kps_{pre-call} \vert$}
    \Function{ClassifyNegatives}{proj, kps, threshold}
    \ForAll{$k \in kps$}
        \State$closest \gets \Call{FindClosestFrom}{proj, k}$
        \If{$\Call{distance}{closest, k} < threshold$}
            \State$false\_negatives \gets false\_negatives \cup (k, closest)$
            \State$proj \gets proj \setminus closest$
        \EndIf
    \EndFor%
    \State{$true\_negatives \gets kps \setminus false\_negatives$}
    \EndFunction%
\end{algorithmic}
\caption{After the explicit found matches are classified, the remaining keypoints need analysis to assign them as true or false positive.}
\end{algorithm}
To classify the negatives each keypoint's distance from $I_2$ to the backprojected keypoints from $I_1$ is tested to be within the defined threshold.
If this is the case, both keypoints are defined as corresponding and result in a false negative. The remaining points are true negatives.
The final partitioning of the keypoints allows to analyze more aspects of keypoints, e.g.~the descriptor distances for true and false positives.

\subsubsection{Histograms and Summary Statistics}

To visualize and understand the analyze the distribution of properties of keypoints and matches, the partitioned keypoint's are tracked in histograms.
Summary statistics reduce the statistical distributions to a few representative values.
Combining different measures, such as the measure of location, distribution and shape gives key insights.

Both histograms and its summary statistics are created for the keypoint size, keypoint response, descriptor distance between all keypoints and both descriptor distance for \emph{true-positives} and \emph{false-positives}.
The quantitive measures for each property are
\begin{itemize}
    \item the \emph{minimum} and \emph{maximum} value,
    \item \emph{median} and \emph{arithmetic mean},
    \item \emph{variance} and \emph{standard deviation}
    \item and \emph{skeweness} of the distribution.
\end{itemize}

\subsubsection{Classification Evaluation}

The analysis of the keypoint and descriptor characteristics give already some insight into the algorithm performance but are not suitable for a comparison between different algorithms and help not to find potential trade-offs.
For this task the quality of the decisions the keypoint matching algorithm is required.
The evaluation builds on the analysis of binary classifiers as introduced in Section~\ref{sec:statistic_classifier}.

The matching of descriptors is done in a simple but consistent way.
A match is defined as the closest descriptor in the other image, that also matches in the other direction.
No other criteria like a maximum matching distance is taken into account.
The matching is assessed with the computed groundtruth data.
For each obtained confusion matrix, the ratios
\begin{itemize}
    \item \emph{precision},
    \item \emph{recall} or \emph{sensitivity},
    \item \emph{fallout} or \emph{false alarm rate},
    \item \emph{accuracy} or \emph{rand-index},
    \item \emph{youden-index}
\end{itemize}
are computed at first.
For a comparison between algorithms and configurations the results are plotted in \gls{ROC}-space.
